## Part 1 - parsing

The language we are making is an interpreted one. This means that we basically need to implement two things: a **parser** and an **evaluator**.

The job of the parser is to convert the program into something the evaluator understands. The evaluator evaluates whatever the parser produces, and returns the result. Here is a nice diagram to explain everything:

```
            +-----------+        +-------------+
    text    |           |  AST   |             |  result
  +-------->|  parser   |+------>|  evaluator  |+-------->
            |           |        |             |
            +-----------+        +-------------+
```

The format produced by the parser is called the *abstract syntax tree* (AST) of the program.

### Our AST

So what do our AST look like? Lets have a sneak peek.

```python
>>> from diylisp.parser import parse
>>> program = """
...   (define fact 
...       ;; Factorial function
...       (lambda (n) 
...           (if (eq n 0) 
...               1 ; Factorial of 0 is 1, and we deny 
...                 ; the existence of negative numbers
...               (* n (fact (- n 1))))))
... """))
>>> parse(program)
['define', 'fact', ['lambda', ['n'], ['if', ['eq', 'n', 0], 1, ['*', 'n', ['fact', ['-', 'n', 1]]]]]]
```

The AST is then created as follows:

- Comments are removed.
- Symbols are represented as strings.
- The lisp list expressions are represented as Python lists.
- The symbols `#t` and `#f` are represented by Pythons `True` and `False, respectively.
- Integers are represented as Python integers.

### Your turn

The parsing is done in `parsing.py`. It is your job to implement the `parse` function here. A lot of the gritty work of counting parentheses and such has been done for you, but you must stitch everything together.

Have a look at the provided functions in the module, and start working. Run the following command until all tests pass.

```bash
nosetests tests/test_1_parsing.py --stop
```
